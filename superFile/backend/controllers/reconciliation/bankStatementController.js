/**
 * @author rahul.jain@zenqore.com
 */

const mongoDB = require("mongodb");
const mongoose = require("mongoose");
const mapperJson = require("./bankStatementMapper.json");
const fs = require("fs");
// const mongoDbUrl = "mongodb://a91573151e7a24db1a19e8a03c7111ba-4ed7d42ccce7dad4.elb.us-east-1.amazonaws.com:30000";
// const dbName = "5f9a6e2325c3670009b50a86";
const bseCollectionName = "bankstmtentries";
const orgListSchema = require("../../models/orglists-schema");
const bseSchema = require("../../models/schemas/bankStatementEntries-model");
var multer = require("multer");
const upload = multer().single("file");
const {
  checkDatabaseExists,
  createDatabase,
  createConnection,
} = require("../../models/db_creation");

/**
 * Takes a JSON (generated by Mehul's code), parses it,
 * and saves the parsed data into the MongoDB collection - 'bankstatemententries'
 * @param {*} bankStmtFilePath - path to the JSON file that was generated by Mehul
 */
async function addBankStatements(req, res) {
  upload(req, res, async function (err) {
    if (err instanceof multer.MulterError) {
      res.status(400).send({
        status: "failed",
        message: err,
      });
    } else if (err) {
      res.status(400).send({
        status: "failed",
        message: err,
      });
    }
    if (!req.file) {
      res.status(400).send({
        status: "failed",
        message: "Please upload a file ",
      });
    }
    const { orgId } = req.params;
    const centralDbConnection = await createDatabase(
      `usermanagement-${process.env.stage}`,
      process.env.central_mongoDbUrl
    );
    const orgListModel = centralDbConnection.model(
      "orglists",
      orgListSchema,
      "orglists"
    );
    const orgData = await orgListModel.findOne({
      _id: orgId,
    });
    if (!orgData || orgData == null) {
      centralDbConnection.close();
      res.status(500).send({
        status: "failure",
        message: "Organization not found",
      });
    }
    const dbConnection = await createConnection(orgId, orgData.connUri);

    let bankStmt = JSON.parse(req.file.buffer);
    console.log(bankStmt);
    const map = mapperJson[bankStmt.bank];
    // console.log(map);
    let dateCol = map.txnDateColPosition;
    let dateFormat = map.dateFormat;
    let dateDelimiter = map.dateDelimiter;
    let debitCol = map.debitColPosition;
    let creditCol = map.creditColPosition;
    let balanceCol = map.balanceColPosition;
    let descriptionCol = map.descriptionPosition;
    let blankEntry = map.blankEntry;
    let chequeOrRefCol = map.chequeOrRefColPosition;
    let tokenChar = map.primaryTokenizer;
    let descFormat = map.descriptionFormat;
    let isAscending = map.ascendingOrder;

    let txnCount = 0;
    let creditCount = 0;
    let debitCount = 0;
    var totalCredit = 0.0;
    var totalDebit = 0.0;
    // var balanceInInput = 0.0;
    var computedBalance = 0.0;
    console.log("bank: " + bankStmt.bank);
    console.log("account_number: " + bankStmt.account_number);
    console.log("tokenChar: " + tokenChar);
    var BseModel = dbConnection.model(bseCollectionName, bseSchema);

    var entries;
    if (isAscending) {
      console.log("ascending .. ");
      entries = bankStmt.entries;
    } else {
      console.log("descending ............................ ");
      entries = bankStmt.entries.reverse();
    }
    for (entry of entries) {
      // entries.forEach(async function (entry) {
      let bseData = {
        bankName: bankStmt.bank.trim(),
        accountNumber: bankStmt.account_number,
      };
      bseData.transactionDate = stringToDate(
        entry[dateCol],
        dateFormat,
        dateDelimiter
      );
      bseData.chequeOrRefNo = entry[chequeOrRefCol];
      bseData.description = entry[descriptionCol];
      let debitVal = 0.0;
      let creditVal = 0.0;
      if (entry[debitCol] != null && entry[debitCol] != blankEntry) {
        debitVal = removeCommas(entry[debitCol]);
        if (debitVal != 0) {
          totalDebit += debitVal;
          debitCount++;
          if (txnCount != 0) {
            computedBalance =
              Math.round((computedBalance - debitVal + Number.EPSILON) * 100) /
              100;
          } else {
            computedBalance = removeCommas(entry[balanceCol]);
          }
          bseData.debitAmount = debitVal;
          bseData.creditAmount = 0.0;
          bseData.balance = computedBalance;
          console.log(
            entry[dateCol] +
              " | db " +
              debitVal +
              " | balance " +
              computedBalance +
              " | cheque/Ref " +
              entry[chequeOrRefCol] +
              " | " +
              entry[descriptionCol]
          );

          let descriptionTokens = bseData.description;
          if (descFormat != null && descFormat != "") {
            tokenizer = "long unwated never used string xxx yyy";
            if (bseData.description.toUpperCase().startsWith("NEFT")) {
              tokenizer = descFormat.debit.NEFT.tokenizer;
              descriptionTokens = bseData.description.split(tokenizer);
              bseData.mode = descriptionTokens[0].trim();
              bseData.bankTxnId = descriptionTokens[1].trim();
              bseData.beneficiary = descriptionTokens[3].trim();
            }
          }
          console.log("description tokens: " + descriptionTokens);
        }
      }
      if (entry[creditCol] != null && entry[creditCol] != blankEntry) {
        creditVal = removeCommas(entry[creditCol]);
        if (creditVal != 0) {
          totalCredit += creditVal;
          creditCount++;
          if (txnCount != 0) {
            computedBalance =
              Math.round((computedBalance + creditVal + Number.EPSILON) * 100) /
              100;
          } else {
            computedBalance = removeCommas(entry[balanceCol]);
          }
          bseData.creditAmount = creditVal;
          bseData.debitAmount = 0.0;
          bseData.balance = computedBalance;
          console.log(
            entry[dateCol] +
              " | CR " +
              creditVal +
              " | balance " +
              computedBalance +
              " | cheque/Ref " +
              entry[chequeOrRefCol] +
              " | " +
              entry[descriptionCol]
          );

          let descriptionTokens = bseData.description;
          if (descFormat != null && descFormat != "") {
            tokenizer = "long unwated never used string xxx yyy";
            if (bseData.description.toUpperCase().startsWith("NEFT")) {
              tokenizer = descFormat.credit.NEFT.tokenizer;
              descriptionTokens = bseData.description.split(tokenizer);
              bseData.fromBank = descriptionTokens[1].trim();
              bseData.mode = descriptionTokens[0].trim();
              bseData.bankTxnId = descriptionTokens[4].trim();
              bseData.depositor = descriptionTokens[2].trim();
              bseData.beneficiary = descriptionTokens[3].trim();
            } else if (bseData.description.toUpperCase().startsWith("IMPS")) {
              tokenizer = descFormat.credit.IMPS.tokenizer;
              descriptionTokens = bseData.description.split(tokenizer);
              bseData.fromBank = descriptionTokens[5].trim();
              bseData.mode = descriptionTokens[0].trim();
              bseData.depositor = descriptionTokens[2].trim();
            }
          }
          console.log("description tokens: " + descriptionTokens);
        }
      }

      if (debitVal != 0 || creditVal != 0) {
        txnCount++;
        let bseModel = new BseModel(bseData);
        var savedData = await bseModel.save();
      }
    } // for
    // }); // foreach

    totalCredit = Math.round((totalCredit + Number.EPSILON) * 100) / 100;
    totalDebit = Math.round((totalDebit + Number.EPSILON) * 100) / 100;

    console.log("txn count: " + txnCount);
    console.log(
      "no of credits: " + creditCount + " | total credit: " + totalCredit
    );
    console.log(
      "no of debits : " + debitCount + " | total debit: " + totalDebit
    );
    console.log("----------------------------------------------");
    dbConnection.close();
    centralDbConnection.close();
    res.status(200).send({
      status: "success",
      message: "Bank statement uploaded successfully",
      data: {
        txnCount,
        creditCount,
        debitCount,
      },
    });
  });
} // parseDataMapJson

async function findStr(str) {
  const dbConnection = await createConnection(dbName, mongoDbUrl);
  let model = dbConnection.model(bseCollectionName, bseSchema);

  try {
    // let data = await model.find({"description": /mehul/i});
    let data = await model.find({ description: new RegExp(str, "i") });
    console.log("data: " + data);
    console.log("data.length: " + data.length);
  } catch (err) {
    throw err;
  } finally {
    dbConnection.close();
  }
}

/**
 * helper function - removes all the commas from a string that represents amount
 * @param {*} stringAmount
 */
function removeCommas(stringAmount) {
  if (stringAmount == null || stringAmount == "") return 0.0;
  else return parseFloat(stringAmount.replace(/[,]/g, ""));
}

function stringToDate(_date, _format, _delimiter) {
  try {
    // console.log(_date + " " + _format + " " + _delimiter);
    var dateStr = "";
    var formatLowerCase = _format.toLowerCase();
    if (formatLowerCase == "ddmonyy") {
      var date = _date.substring(0, 2);
      var month = _date.substring(2, 5);
      var year = _date.substring(5, 7);
      dateStr = month + " " + date + " " + year + " 00:00:00 UTC";
    } else if (
      formatLowerCase == "dd mon yyyy" ||
      formatLowerCase == "dd-mon-yyyy"
    ) {
      var date = _date.substring(0, 2);
      var month = _date.substring(3, 6);
      var year = _date.substring(7, 11);
      dateStr = month + " " + date + " " + year + " 00:00:00 UTC";
    } else if (formatLowerCase == "dd-mm-yy" || formatLowerCase == "dd/mm/yy") {
      var date = _date.substring(0, 2);
      var month = _date.substring(3, 5);
      var year = _date.substring(6, 8);
      dateStr = "20" + year + "-" + month + "-" + date + " 00:00:00 UTC";
    } else if (
      formatLowerCase == "dd-mm-yyyy" ||
      formatLowerCase == "dd/mm/yyyy"
    ) {
      var date = _date.substring(0, 2);
      var month = _date.substring(3, 5);
      var year = _date.substring(6, 10);
      dateStr = year + "-" + month + "-" + date + " 00:00:00 UTC";
    } else if (formatLowerCase == "dd/mm/ yyyy") {
      var date = _date.substring(0, 2);
      var month = _date.substring(3, 5);
      var year = _date.substring(7, 11);
      dateStr = year + "-" + month + "-" + date + " 00:00:00 UTC";
    } else {
      var formatItems = formatLowerCase.split(_delimiter);
      var dateItems = _date.split(_delimiter);
      var monthIndex = formatItems.indexOf("mm");
      var dayIndex = formatItems.indexOf("dd");
      var yearIndex = formatItems.indexOf("yyyy");
      var month = parseInt(dateItems[monthIndex]);
      // month -= 1;
      if (dateItems[yearIndex].length == 2) {
        dateItems[yearIndex] = "20" + dateItems[yearIndex];
      }
      // var formatedDate = new Date(dateItems[yearIndex], month, dateItems[dayIndex]);
      dateStr =
        dateItems[yearIndex] +
        "-" +
        month +
        "-" +
        dateItems[dayIndex] +
        " 00:00:00 UTC";
    }
    // console.log(dateStr);
    var formatedDate = new Date(dateStr);
    return formatedDate;
  } catch (err) {
    console.log(err);
    return null;
  }
} // stringToDate

// to test the stringToDate function
// console.log(stringToDate("17/9/2014","dd/MM/yyyy","/"));
// console.log(stringToDate("9/17/2014","mm/dd/yyyy","/"));
// console.log(stringToDate("9-17-2014","mm-dd-yyyy","-"));
// console.log(stringToDate("14-05-2020","dd-mm-yyyy","-"));
// console.log(stringToDate("14-05-20","dd-mm-yyyy","-"));
// console.log(stringToDate("23Sep16","ddMonyy",""));
// console.log(stringToDate("23-Oct-2019","dd-Mon-yyyy",""));

async function getBankStatements(req, res) {
  const { orgId } = req.params;
  const centralDbConnection = await createDatabase(
    `usermanagement-${process.env.stage}`,
    process.env.central_mongoDbUrl
  );
  const orgListModel = centralDbConnection.model(
    "orglists",
    orgListSchema,
    "orglists"
  );
  const orgData = await orgListModel.findOne({
    _id: orgId,
  });
  if (!orgData || orgData == null) {
    centralDbConnection.close();
    res.status(500).send({
      status: "failure",
      message: "Organization not found",
    });
  }
  const dbConnection = await createConnection(orgId, orgData.connUri);
  const bseModel = dbConnection.model(bseCollectionName, bseSchema);
  bseModel
    .find(req.query)
    .then((data) => {
      res.status(200).send({
        status: "success",
        message: "get bank statement entries",
        data,
      });
      centralDbConnection.close() // new
      dbConnection.close() // new
    })
    .catch((err) => {
      res.status(500).send({
        status: "failure",
        message: "unable to get bank statement entries",
        data: err,
      });
      centralDbConnection.close() // new
      dbConnection.close() // new
    })
    .finally((value) => {
      dbConnection.close();
      centralDbConnection.close();
    });
}

module.exports = {
  addBankStatements,
  getBankStatements,
};
